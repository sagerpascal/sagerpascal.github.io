---
layout: custom_post
title: 2048 - Implementierung meiner ersten AI
categories:
- ICT
feature_image: "https://user-images.githubusercontent.com/46379095/67037305-90f79100-f11d-11e9-86d5-60ed4e39f3a8.PNG"
comments: true
---

*Dieser Blogeintrag entstand in Form des ersten Praktikums des Faches Artificial Intelligence an der Zürcher Hochschule für Angewandte Wissenschaften*

# 2048 - Kann unsere AI für uns gewinnen?

2048 ist definitiv ein Spiel, das süchtig machen kann. Das Spielfeld besteht aus 16 Feldern mit den Zahlen aus der Folge:

> <a href="https://www.codecogs.com/eqnedit.php?latex=a_{n}=2^n&space;\text{&space;wobei&space;gilt&space;}&space;n=0,1,2,..." target="_blank"><img src="https://latex.codecogs.com/svg.latex?a_{n}=2^n&space;\text{&space;wobei&space;gilt&space;}&space;n=0,1,2,..." title="a_{n}=2^n \text{ wobei gilt } n=0,1,2,..." /></a>

Das Ziel ist, dass identische Zahlen zu einer neuen Zahl zusammengeschoben werden, wobei die neue Zahl der Summe der zusammengeschobenen Zahlen besteht. Das Spiel kann kostenlos unter [https://play2048.co](https://play2048.co) gespielt werden.

Im Rahmen des Faches Artificial Intelligence an der Zürcher Hochschule wurde uns ein Programm zu Verfügung gestellt, mit welchem das Spiel im Browser angesteuert werden kann. Die Challenge bestand darin, eine Heuristic AI sowie eine Search AI zu programmieren, welche ein gutes Ergebnis in diesem Spiel erzielen sollten.

Wenn wir das Spiel manuell gespielt haben, konnten wir meist nur etwa 16'000 Punkte erreichen und gewannen das Spiel nur selten. Dies konnten wir nicht auf uns sitzen lassen und die Challenge war schnell definiert - Die AI soll das Spiel für uns gewinnen. Und zwar immer.



# Heuristic AI

Das Ziel der Heuristic AI ist, anhand des aktuellen Spielzustands den nächstbesten Zug vorauszusagen. Es ist explizit definiert, dass nicht mehrere Züge vorausberechnet sondern nur der aktuelle Spielzustand bewertet werden darf. Zu Beginn wurden nortiert, was alles hilfreich sein kann beim Spiel. Dabei wurden folgende Punkte evaluiert:

- Grosse Zahlen sollten am Rand sein
- Gleiche Zahlen sollten nebeneinander sein
- Grosse Zahlen zusammenschieben ist wichtiger als kleine zusammenzuschieben
- ... WEITERE AUFSCHREIBEN

Zu Beginn wurden die obigen Punkte einzeln implementiert, jedoch brachte diese nicht den gewünschten Erfolg. Schliesslich haben wir uns für eine Kombination sämtlicher Punkte entschieden - und eine Tabelle aufgestellt, was wie viele Punkte bringen soll. Dies führte jedoch letzlich zu mehr Chaos als zum Ziel und es musste eine neue Lösung her. Statt auf Tabellen haben wir fortan auf Matrizen gesetzt. So wurden in der Matrize <a href=""><img src="https://latex.codecogs.com/gif.latex?W" title="W" /></a> Gewichte definiert, welche mit dem aktuellen Spielstand <a href=""><img src="https://latex.codecogs.com/gif.latex?G" title="G" /></a> anhand folgender Formel berechnet werden:

> <a href="https://www.codecogs.com/eqnedit.php?latex=W\circ&space;G&space;=&space;\begin{bmatrix}&space;w_{11}&space;&&space;w_{21}&space;&&space;w_{31}&space;&&space;w_{41}\\&space;w_{12}&space;&&space;w_{22}&space;&&space;w_{32}&space;&&space;w_{42}\\&space;w_{13}&space;&&space;w_{23}&space;&&space;w_{33}&space;&&space;w_{43}\\&space;w_{14}&space;&&space;w_{24}&space;&&space;w_{34}&space;&&space;w_{44}\\&space;\end{bmatrix}&space;\circ&space;\begin{bmatrix}&space;g_{11}&space;&&space;g_{21}&space;&&space;g_{31}&space;&&space;g_{41}\\&space;g_{12}&space;&&space;g_{22}&space;&&space;g_{32}&space;&&space;g_{42}\\&space;g_{13}&space;&&space;g_{23}&space;&&space;g_{33}&space;&&space;g_{43}\\&space;g_{14}&space;&&space;g_{24}&space;&&space;g_{34}&space;&&space;g_{44}\\&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;w_{11}\ast&space;g_{11}&space;&&space;w_{21}\ast&space;g_{21}&space;&&space;w_{31}\ast&space;g_{31}&space;&&space;w_{41}\ast&space;g_{41}\\&space;w_{12}\ast&space;g_{12}&space;&&space;w_{22}\ast&space;g_{22}&space;&&space;w_{32}\ast&space;g_{32}&space;&&space;w_{42}\ast&space;g_{42}\\&space;w_{13}\ast&space;g_{13}&space;&&space;w_{23}\ast&space;g_{23}&space;&&space;w_{33}\ast&space;g_{33}&space;&&space;w_{43}\ast&space;g_{43}\\&space;w_{14}\ast&space;g_{14}&space;&&space;w_{24}\ast&space;g_{24}&space;&&space;w_{34}\ast&space;g_{34}&space;&&space;w_{44}\ast&space;g_{44}\\&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?W\circ&space;G&space;=&space;\begin{bmatrix}&space;w_{11}&space;&&space;w_{21}&space;&&space;w_{31}&space;&&space;w_{41}\\&space;w_{12}&space;&&space;w_{22}&space;&&space;w_{32}&space;&&space;w_{42}\\&space;w_{13}&space;&&space;w_{23}&space;&&space;w_{33}&space;&&space;w_{43}\\&space;w_{14}&space;&&space;w_{24}&space;&&space;w_{34}&space;&&space;w_{44}\\&space;\end{bmatrix}&space;\circ&space;\begin{bmatrix}&space;g_{11}&space;&&space;g_{21}&space;&&space;g_{31}&space;&&space;g_{41}\\&space;g_{12}&space;&&space;g_{22}&space;&&space;g_{32}&space;&&space;g_{42}\\&space;g_{13}&space;&&space;g_{23}&space;&&space;g_{33}&space;&&space;g_{43}\\&space;g_{14}&space;&&space;g_{24}&space;&&space;g_{34}&space;&&space;g_{44}\\&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;w_{11}\ast&space;g_{11}&space;&&space;w_{21}\ast&space;g_{21}&space;&&space;w_{31}\ast&space;g_{31}&space;&&space;w_{41}\ast&space;g_{41}\\&space;w_{12}\ast&space;g_{12}&space;&&space;w_{22}\ast&space;g_{22}&space;&&space;w_{32}\ast&space;g_{32}&space;&&space;w_{42}\ast&space;g_{42}\\&space;w_{13}\ast&space;g_{13}&space;&&space;w_{23}\ast&space;g_{23}&space;&&space;w_{33}\ast&space;g_{33}&space;&&space;w_{43}\ast&space;g_{43}\\&space;w_{14}\ast&space;g_{14}&space;&&space;w_{24}\ast&space;g_{24}&space;&&space;w_{34}\ast&space;g_{34}&space;&&space;w_{44}\ast&space;g_{44}\\&space;\end{bmatrix}" title="W\circ G = \begin{bmatrix} w_{11} & w_{21} & w_{31} & w_{41}\\ w_{12} & w_{22} & w_{32} & w_{42}\\ w_{13} & w_{23} & w_{33} & w_{43}\\ w_{14} & w_{24} & w_{34} & w_{44}\\ \end{bmatrix} \circ \begin{bmatrix} g_{11} & g_{21} & g_{31} & g_{41}\\ g_{12} & g_{22} & g_{32} & g_{42}\\ g_{13} & g_{23} & g_{33} & g_{43}\\ g_{14} & g_{24} & g_{34} & g_{44}\\ \end{bmatrix} = \begin{bmatrix} w_{11}\ast g_{11} & w_{21}\ast g_{21} & w_{31}\ast g_{31} & w_{41}\ast g_{41}\\ w_{12}\ast g_{12} & w_{22}\ast g_{22} & w_{32}\ast g_{32} & w_{42}\ast g_{42}\\ w_{13}\ast g_{13} & w_{23}\ast g_{23} & w_{33}\ast g_{33} & w_{43}\ast g_{43}\\ w_{14}\ast g_{14} & w_{24}\ast g_{24} & w_{34}\ast g_{34} & w_{44}\ast g_{44}\\ \end{bmatrix}" /></a>



Danach verschiedene Matrizen mit Gewichten aufschreiben und wie diese berechnet wurden und Grafiken erstellen, was dies für einen Einfluss auf den Code hatte.



So können Matrizen gemacht werden: [https://www.codecogs.com/eqnedit.php?latex=/mathcal{W}(A,f)&space;=&space;(T,/bar{f})](https://www.codecogs.com/eqnedit.php?latex=/mathcal{W}(A,f)&space;=&space;(T,/bar{f}))



Dies geht nicht:
$$
\begin{bmatrix}1 & 2 & 3 & 4\\ 1 & 2 & 3 & 4\\ 1 & 2 & 3 & 4\\ 1 & 2 & 3 & 4\\\end{bmatrix}
$$




# Search AI

Im Gegensatz zur Heuristic AI darf die Search AI die nächsten Züge vorausberechnen.  Dazu kommt eine leicht abgeänderte Form des Expectimax-Algorithmus zum Einsatz. Dabei wird eine Baumstruktur mit allen möglichen Spiel-Situationen aufgebaut. Der oberste Node des Baums ist das aktuelle Spielfeld. Danach ist der  Spieler am Zug und hat vier mögliche Aktionen zur Auswahl: `UP`, `DOWN`, `LEFT` und `RIGHT`. Danach kommt der Zufallsgenerator des Spiels zum Zugs, welcher mit einer Wahrscheinlichkeit von 90% eine 2 an einer freien Stelle platziert und zu 10% eine 4 an einer freien Stellen. Im Worst-Case, dies ist wenn nur 1 Feld besetzt ist, führt dies also zu <a href="https://www.codecogs.com/eqnedit.php?latex=4\ast&space;(2\ast&space;15)=120" target="_blank"><img src="https://latex.codecogs.com/svg.latex?4\ast&space;(2\ast&space;15)=120" title="4\ast (2\ast 15)=120" /></a>neuen Kombinationen. Angenommen im Schnitt sind <a href="https://www.codecogs.com/eqnedit.php?latex=7.5" target="_blank"><img src="https://latex.codecogs.com/svg.latex?7.5" title="7.5" /></a> Felder belegt, dann ergeben sich bei einer Tiefe  <a href="https://www.codecogs.com/eqnedit.php?latex=d" target="_blank"><img src="https://latex.codecogs.com/svg.latex?d" title="d" /></a> die folgende Anzahl an Ästen (wobei <a href="https://www.codecogs.com/eqnedit.php?latex=d=1" target="_blank"><img src="https://latex.codecogs.com/svg.latex?d=1" title="d=1" /></a> einem Durchgang für den Spieler und einen Durchgang für den Zufallsgenerator des Spiels entspricht):

> <a href="https://www.codecogs.com/eqnedit.php?latex=4^d&space;\ast&space;15^d" target="_blank"><img src="https://latex.codecogs.com/svg.latex?4^d&space;\ast&space;15^d" title="4^d \ast 15^d" /></a>

Da dies schnell zu einer kombinatorischen Explosion führt, müssen geeignete Massnahmen getroffen werden, damit zum einen der Code genügend schnell läuft und zum anderen eine ausreichend tiefe Baumsuchtiefe erreicht werden kann.

- Code optimieren betreffend Effizienz
- "Schlechte" Äste abschneiden
- Äste mit Zügen welche nichts bewirken abschneiden
- gute Heuristic zum abschätzen, wie gut der Ast ist



### Code optimieren

Der ursprüngliche Code bestand aus einer Klasse Node, welcher einen Knoten im Baum repräsentierte. Nachfolgender Pseudocode zeigt die Struktur dieser Klasse:

```python
class Node:
	def __init__(self, parent, board):
		self.parent = parent
		self.board = board
		
	def get_points(self):
		return Heuristic.evaluate_board(board)		
```

Der oberste Node im Baum war dabei das aktuelle Board, die unteren Nodes wurden für jeden möglichen Move sowie jede mögliche Zufallszahl erzeugt. Es musste aber festgestellt werden, dass der Code bereits ab einer Tiefe von <a href="https://www.codecogs.com/eqnedit.php?latex=d=3" target="_blank"><img src="https://latex.codecogs.com/svg.latex?d=3" title="d=3" /></a> langsam läuft.



##### Die Idee mit dem Stack

Während einer Pause kam uns eine verrückte Idee - Wir könnten die Klasse `Node` komplett weglassen und stattdessen mit rekursiven Aufrufen direkt den Stack nutzen - Ob dies schneller oder langsamer ist? Wir hatten keine Ahnung. Wir implementierten also einen rekursiven Aufruf und merkten uns, wer an der Reihe ist

- Agent `GAME_AGENT`: Das Spiel ist am Zug, dieses platziert an jeder freien Stelle eine 2 oder eine 4
- Agent `GAMER_AGENT`: Der Spieler ist am Zug und kann zwischen den 4 Aktionen `UP`, `DOWN`, `LEFT` und `RIGHT` wählen.

Pseudocode:

```python
def calc_best_move(board, depth, agent):
    if depth == 0:
        return get_score(board)

    if agent == GAME_AGENT:
        points = 0
        for empty_tilde in empty_tildes:
            empty_fields += 1
            new_board = board.copy()
            new_board.where(empty_tilde) = 2
            points += 0.9 * calc_best_move(new_board, depth - 1, GAMER_AGENT)
            new_board = board.copy()
            new_board.where(empty_tilde) = 4
            points += 0.1 * calc_best_move(new_board, depth - 1, GAMER_AGENT)
        return points / len(empty_tildes)

    elif agent == GAMER_AGENT:
        points = 0
        for move in [LEFT, RIGHT, UP, DOWN]:
            new_board = board.copy()
            new_board = execute_move(move, new_board)
            if not board_equals(board, new_board): 
                points = max(points, calc_best_move(new_board, depth - 1, GAME_AGENT))
        return points
```



Der `GAMER_AGENT` ruft also die `GAME_AGENT` auf und umgekehrt und jedes mal wird die Tiefe um 1 dekrementiert. Sobald die Tiefe 0 erreicht wurde, werden die Punkte berechnet und zurückgegeben.

Diese Strategie mit dem Wechsel auf den Stack hat sich durchaus bezahlt gemacht. So konnte die Geschwindigkeit um markant gesteigert werden und die Suchtiefe von <a href="https://www.codecogs.com/eqnedit.php?latex=d=3" target="_blank"><img src="https://latex.codecogs.com/svg.latex?d=3" title="d=3" /></a> war fortan problemlos möglich.

##### Optimierung der Bewertungsfunktion

Die Bewertung wie gut ein eine Konstellation auf dem Board ist erfolgt anhand einer Matrix-Gewichtung, welche aus zwei Teilen besteht. Zum einen gibt es Plus-Punkte wenn die Steine gut angeordnet sind, zum anderen einen Abzug falls die Steine nebeneinader ein grosses Delta aufweisen. 

Definition einer guten Anordnung:

> <a href="https://www.codecogs.com/eqnedit.php?latex=W\circ&space;G&space;=&space;\begin{bmatrix}&space;6&space;&&space;5&space;&&space;4&space;&&space;1\\&space;5&space;&&space;4&space;&&space;1&space;&&space;0\\&space;4&space;&&space;1&space;&&space;0&space;&&space;-1\\&space;1&space;&&space;0&space;&&space;-1&space;&&space;-2\\&space;\end{bmatrix}&space;\circ&space;\begin{bmatrix}&space;g_{11}&space;&&space;g_{21}&space;&&space;g_{31}&space;&&space;g_{41}\\&space;g_{12}&space;&&space;g_{22}&space;&&space;g_{32}&space;&&space;g_{42}\\&space;g_{13}&space;&&space;g_{23}&space;&&space;g_{33}&space;&&space;g_{43}\\&space;g_{14}&space;&&space;g_{24}&space;&&space;g_{34}&space;&&space;g_{44}\\&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;6\ast&space;g_{11}&space;&&space;5\ast&space;g_{21}&space;&&space;4\ast&space;g_{31}&space;&&space;g_{41}\\&space;5\ast&space;g_{12}&space;&&space;4\ast&space;g_{22}&space;&&space;g_{32}&space;&&space;0\\&space;4\ast&space;g_{13}&space;&&space;g_{23}&space;&&space;0&space;&&space;-&space;g_{43}\\&space;g_{14}&space;&&space;0&space;&&space;-&space;g_{34}&space;&&space;-2\ast&space;g_{44}\\&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/svg.latex?W\circ&space;G&space;=&space;\begin{bmatrix}&space;6&space;&&space;5&space;&&space;4&space;&&space;1\\&space;5&space;&&space;4&space;&&space;1&space;&&space;0\\&space;4&space;&&space;1&space;&&space;0&space;&&space;-1\\&space;1&space;&&space;0&space;&&space;-1&space;&&space;-2\\&space;\end{bmatrix}&space;\circ&space;\begin{bmatrix}&space;g_{11}&space;&&space;g_{21}&space;&&space;g_{31}&space;&&space;g_{41}\\&space;g_{12}&space;&&space;g_{22}&space;&&space;g_{32}&space;&&space;g_{42}\\&space;g_{13}&space;&&space;g_{23}&space;&&space;g_{33}&space;&&space;g_{43}\\&space;g_{14}&space;&&space;g_{24}&space;&&space;g_{34}&space;&&space;g_{44}\\&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;6\ast&space;g_{11}&space;&&space;5\ast&space;g_{21}&space;&&space;4\ast&space;g_{31}&space;&&space;g_{41}\\&space;5\ast&space;g_{12}&space;&&space;4\ast&space;g_{22}&space;&&space;g_{32}&space;&&space;0\\&space;4\ast&space;g_{13}&space;&&space;g_{23}&space;&&space;0&space;&&space;-&space;g_{43}\\&space;g_{14}&space;&&space;0&space;&&space;-&space;g_{34}&space;&&space;-2\ast&space;g_{44}\\&space;\end{bmatrix}" title="W\circ G = \begin{bmatrix} 6 & 5 & 4 & 1\\ 5 & 4 & 1 & 0\\ 4 & 1 & 0 & -1\\ 1 & 0 & -1 & -2\\ \end{bmatrix} \circ \begin{bmatrix} g_{11} & g_{21} & g_{31} & g_{41}\\ g_{12} & g_{22} & g_{32} & g_{42}\\ g_{13} & g_{23} & g_{33} & g_{43}\\ g_{14} & g_{24} & g_{34} & g_{44}\\ \end{bmatrix} = \begin{bmatrix} 6\ast g_{11} & 5\ast g_{21} & 4\ast g_{31} & g_{41}\\ 5\ast g_{12} & 4\ast g_{22} & g_{32} & 0\\ 4\ast g_{13} & g_{23} & 0 & - g_{43}\\ g_{14} & 0 & - g_{34} & -2\ast g_{44}\\ \end{bmatrix}" /></a>



Der Penalty hingegen führt zu einem Abzug, wenn verschieden grosse Felder nebeneinander angeordnet sind:

```python
def get_penalty_unequal_neighbours(board):
    penalty = 0
    for i in range(0, 3):
        for j in range(0, 3):
            penalty += abs(board[i][j] - board[i][j + 1]) * 2
            penalty += abs(board[i][j] - board[i + 1][j]) * 2
    return penalty
```

Der cProfiler zeigte jedoch auf, dass genau in dieser Bewertung unsere grösste Ineffizienz lag. Nach 60 Sekunden zeigte die Statistik folgende Werte an:

| Name                               | Call Count  | Time (ms) | Own Time(ms)      |
| ---------------------------------- | ----------- | --------- | ----------------- |
| **get_penalty_unequal_neighbours** | **1118718** | **28555** | **27118 (44.2%)** |
| calc_best_move                     | 1258403     | 58984     | 7723 (12.6%)      |
| numpy.array                        | 1371177     | 4567      | 4567 (7.4%)       |
| numpy.ufunc                        | 1244866     | 3291      | 3291 (5.4%)       |
| get_points_value_distribution      | 1118718     | 14425     | 2813 (4.6%)       |
| ...                                | ...         | ...       | ...               |

Die betroffene Methode wurde wie folgt optimiert:

```python
def get_penalty_unequal_neighbours(board):
    penalty = numpy.sum(numpy.absolute(numpy.diff(board)))
    penalty += numpy.sum(numpy.absolute(numpy.diff(numpy.swapaxes(board, 0, 1))))
    return penalty
```



Danach wurde ein weiteres Profile aufgenommen und es wurde ersichtlich, dass der Code nun einiges effizienter ist:

| Name                               | Call Count | Time (ms) | Own Time(ms)    |
| ---------------------------------- | ---------- | --------- | --------------- |
| diff                               | 1922146    | 13604     | 11533 (18.9%)   |
| calc_best_move                     | 1040854    | 60383     | 7182 (11.7%)    |
| numpy.ufunc                        | 2952499    | 7060      | 7060 (7.6%)     |
| numpy.array                        | 3021824    | 4639      | 4639 (6.2%)     |
| **get_penalty_unequal_neighbours** | **961073** | **34999** | **3822 (6.2%)** |
| ...                                | ...        | ...       | ...             |



### Heuristic optimieren





# DQN

